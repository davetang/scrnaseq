---
title: "Preprocessing and clustering 3k PBMCs"
format: html
jupyter: python3
---

# Using scanpy

[Preprocessing and clustering 3k PBMCs](https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html)

## Initialise

Use [reticulate](https://rstudio.github.io/reticulate/).

```{r load_reticulate}
library(reticulate)
use_python("/usr/bin/python3")
reticulate::py_config()
```

Load Python modules.

```{python}
import pandas as pd
import scanpy as sc
sc.settings.verbosity = 3  # verbosity: errors (0), warnings (1), info (2), hints (3)
sc.logging.print_header()
sc.settings.set_figure_params(dpi=80, facecolor="white")
```

File that will store the analysis results.

```{python}
results_file = "../results/pbmc3k.h5ad"
```

## Load data

Read in the count matrix into an `AnnData` object, which holds many slots for annotations and different representations of the data. It also comes with its own HDF5-based file format; `.h5ad`; see [scanpy.read_10x_mtx](https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html) for more information.

```{python}
adata = sc.read_10x_mtx(
    "../data/filtered_gene_bc_matrices/hg19/",  # the directory with the `.mtx` file
    var_names="gene_symbols",  # use gene symbols for the variable names (variables-axis index)
    cache=True,  # write a cache file for faster subsequent reading
)

adata
```

## Pre-processing

Show those genes that yield the highest fraction of counts in each single cell, across all cells.

```{python}
sc.pl.highest_expr_genes(adata, n_top=20)
```

Basic filtering:

```{python}
sc.pp.filter_cells(adata, min_genes=200)
sc.pp.filter_genes(adata, min_cells=3)
```

With pp.calculate_qc_metrics, we can compute many metrics very efficiently.

```{python}
# annotate the group of mitochondrial genes as "mt"
adata.var["mt"] = adata.var_names.str.startswith("MT-")
sc.pp.calculate_qc_metrics(
    adata, qc_vars=["mt"], percent_top=None, log1p=False, inplace=True
)
```

A violin plot of some of the computed quality measures:

* the number of genes expressed in the count matrix
* the total counts per cell
* the percentage of counts in mitochondrial genes

```{python}
sc.pl.violin(
    adata,
    ["n_genes_by_counts", "total_counts", "pct_counts_mt"],
    jitter=0.4,
    multi_panel=True,
)
```

Remove cells that have too many mitochondrial genes expressed or too many total counts:

```{python}
sc.pl.scatter(adata, x="total_counts", y="pct_counts_mt")
sc.pl.scatter(adata, x="total_counts", y="n_genes_by_counts")
```

Actually do the filtering by slicing the AnnData object.

```{python}
adata = adata[adata.obs.n_genes_by_counts < 2500, :]
adata = adata[adata.obs.pct_counts_mt < 5, :].copy()
```

Total-count normalize (library-size correct) the data matrix $X$ to 10,000 reads per cell, so that counts become comparable among cells.

```{python}
sc.pp.normalize_total(adata, target_sum=1e4)
```

Logarithmize the data:

```{python}
sc.pp.log1p(adata)
```

Identify highly-variable genes.

```{python}
sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)
```

```{python}
sc.pl.highly_variable_genes(adata)
```

Set the `.raw` attribute of the `AnnData` object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the `AnnData` object. You can get back an `AnnData` of the object in `.raw` by calling `.raw.to_adata()`.

```{python}
adata.raw = adata
```

Actually do the filtering.

```{python}
adata = adata[:, adata.var.highly_variable]
```

Regress out effects of total counts per cell and the percentage of mitochondrial genes expressed. Scale the data to unit variance.

```{python}
sc.pp.regress_out(adata, ["total_counts", "pct_counts_mt"])
```

Scale each gene to unit variance. Clip values exceeding standard deviation 10.

```{python}
sc.pp.scale(adata, max_value=10)
```

## Principal component analysis

Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data.

```{python}
sc.tl.pca(adata, svd_solver="arpack")
```

We can make a scatter plot in the PCA coordinates, but we will not use that later on.

```{python}
sc.pl.pca(adata, color="CST3")
```

Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function `sc.tl.louvain()` or tSNE `sc.tl.tsne()`. In our experience, often a rough estimate of the number of PCs does fine.

```{python}
sc.pl.pca_variance_ratio(adata, log=True)
```

Save the result.

```{python}
adata.write(results_file)
```

## Computing the neighborhood graph

Let us compute the neighborhood graph of cells using the PCA representation of the data matrix. You might simply use default values here. For the sake of reproducing Seurat’s results, let’s take the following values.

```{python}
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)
```

## Embedding the neighborhood graph

We suggest embedding the graph in two dimensions using UMAP (McInnes et al., 2018). It is potentially more faithful to the global connectivity of the manifold than tSNE, i.e., it better preserves trajectories. In some occasions, you might still observe disconnected clusters and similar connectivity violations. They can usually be remedied by running:

```{python}
sc.tl.leiden(adata)
sc.tl.paga(adata)
sc.pl.paga(adata, plot=False)  # remove `plot=False` if you want to see the coarse-grained graph
sc.tl.umap(adata, init_pos='paga')
```

```{python}
sc.tl.umap(adata)
```

```{python}
sc.pl.umap(adata, color=["CST3", "NKG7", "PPBP"])
```

As we set the `.raw` attribute of `adata`, the previous plots showed the "raw" (normalized, logarithmized, but uncorrected) gene expression. You can also plot the scaled and corrected gene expression by explicitly stating that you don't want to use `.raw`.

```{python}
sc.pl.umap(adata, color=["CST3", "NKG7", "PPBP"], use_raw=False)
```

## Clustering the neighborhood graph

As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) by Traag et al. (2018). Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section.

```{python}
sc.tl.leiden(
    adata,
    resolution=0.9,
    random_state=0,
    flavor="igraph",
    n_iterations=2,
    directed=False,
)
```

```{python}
sc.pl.umap(adata, color=["leiden", "CST3", "NKG7"])
```

## Finding marker genes

Let us compute a ranking for the highly differential genes in each cluster. For this, by default, the `.raw` attribute of `AnnData` is used in case it has been initialized before. The simplest and fastest method to do so is the t-test.

```{python}
sc.tl.rank_genes_groups(adata, "leiden", method="t-test")
sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False)
```

```{python}
sc.settings.verbosity = 2  # reduce the verbosity
```

The result of a Wilcoxon rank-sum (Mann-Whitney-U) test is very similar. We recommend using the latter in publications, see e.g., Sonison & Robinson (2018). You might also consider much more powerful differential testing packages like MAST, limma, DESeq2 and, for python, the recent diffxpy.

```{python}
sc.tl.rank_genes_groups(adata, "leiden", method="wilcoxon")
sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False)
```

Let us also define a list of marker genes for later reference.

```{python}
marker_genes = [
    *["IL7R", "CD79A", "MS4A1", "CD8A", "CD8B", "LYZ", "CD14"],
    *["LGALS3", "S100A8", "GNLY", "NKG7", "KLRB1"],
    *["FCGR3A", "MS4A7", "FCER1A", "CST3", "PPBP"],
]
```

Show the 10 top ranked genes per cluster 0, 1, …, 7 in a dataframe.

```{python}
pd.DataFrame(adata.uns["rank_genes_groups"]["names"]).head(5)
```

Get a table with the scores and groups.

```{python}
result = adata.uns["rank_genes_groups"]
groups = result["names"].dtype.names
pd.DataFrame(
    {
        group + "_" + key[:1]: result[key][group]
        for group in groups
        for key in ["names", "pvals"]
    }
).head(5)
```

Compare to a single cluster:

```{python}
sc.tl.rank_genes_groups(adata, "leiden", groups=["0"], reference="1", method="wilcoxon")
sc.pl.rank_genes_groups(adata, groups=["0"], n_genes=20)
```

If you want to compare a certain gene across groups, use the following.

```{python}
sc.pl.violin(adata, ["CST3", "NKG7", "PPBP"], groupby="leiden")
```

Actually mark the cell types.

```{python}
new_cluster_names = [
    "CD4 T",
    "B",
    "FCGR3A+ Monocytes",
    "NK",
    "CD8 T",
    "CD14+ Monocytes",
    "Dendritic",
    "Megakaryocytes",
]
adata.rename_categories("leiden", new_cluster_names)
```

```{python}
sc.pl.umap(
    adata, color="leiden", legend_loc="on data", title="", frameon=False
)
```

Now that we annotated the cell types, let us visualize the marker genes.

```{python}
sc.pl.dotplot(adata, marker_genes, groupby="leiden");
```

There is also a very compact violin plot.

```{python}
sc.pl.stacked_violin(adata, marker_genes, groupby="leiden");
```

During the course of this analysis, the `AnnData` accumulated the following annotations.

```{python}
adata
```

Save.

```{python}
# `compression='gzip'` saves disk space, and slightly slows down writing and subsequent reading
adata.write(results_file, compression="gzip")
```

# AnnData

[Getting started with anndata](https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html).

```{python}
import anndata as ad

adata = sc.read(results_file)
adata
```

* `obs` and `var` correspond to observation and variable level data
* `obsm` and `varm` correspond to observation and variable-level matrices
* `uns` is for any unstructured metadata
* `obsp` is for pairwise annotation of observations

Not in the example above but layers is for storing different forms of the original core data, perhaps one that is normalized and one that is not.

Number of barcodes.

```{python}
adata.n_obs
```

Number of genes.

```{python}
adata.n_vars
```

Barcodes.

```{python}
adata.obs.index
```

Gene IDs.

```{python}
adata.var.gene_ids
```

Subset.

```{python}
adata[
  ["AAACATACAACCAC-1", "TTTGCATGCCTCAC-1"],
  ["TNFRSF4", "PRMT2"]
].var
```

Number of genes.

```{python}
print(adata.obs.n_genes[:10])
```

Unstructured metadata.

```{python}
adata.uns['leiden']
```

Access using R.

```{r r_adata_obs}
py$adata$obs
```

# Using Seurat

[Seurat using sctransform](https://satijalab.org/seurat/articles/sctransform_vignette.html).

```{r load_seurat}
library(Seurat)
library(ggplot2)
library(sctransform)
```

Entire Seurat workflow.

```{r seurat_workflow}
Read10X(data.dir = "../data/filtered_gene_bc_matrices/hg19/") |>
  CreateSeuratObject() |>
  PercentageFeatureSet(pattern = "^MT-", col.name = "percent.mt") |>
  SCTransform(vars.to.regress = "percent.mt") |>
  RunPCA() |>
  FindNeighbors(dims = 1:30) |>
  RunUMAP(dims = 1:30) |>
  FindClusters() -> pbmc

pbmc
```

Assays `SCT` and `RNA`.

```{r seurat_assay}
pbmc[['RNA']]
pbmc[['SCT']]
```

Seurat v5 assays store data in [layers](https://satijalab.org/seurat/articles/seurat5_integration.html). These layers can store raw, un-normalized counts (layer='counts'), normalized data (layer='data'), or z-scored/variance-stabilized data (layer='scale.data'). We can load in the data, remove low-quality cells, and obtain predicted cell annotations (which will be useful for assessing integration later), using our Azimuth pipeline.

```{r seurat_layer}
pbmc[['RNA']]$counts
```

UMAP plot.

```{r dimplot_umap}
DimPlot(pbmc, reduction = "umap")
```

See the [Seurat v5 Command Cheat Sheet](https://satijalab.org/seurat/articles/seurat5_essential_commands.html) for useful commands.
